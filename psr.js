(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.TariffPSR = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,3],$V1=[1,4],$V2=[1,5],$V3=[1,7],$V4=[1,8],$V5=[1,9],$V6=[1,10],$V7=[1,11],$V8=[1,12],$V9=[1,13],$Va=[1,14],$Vb=[1,15],$Vc=[5,7,8,9,11,14,15,16,17,18,20],$Vd=[1,27],$Ve=[1,26],$Vf=[5,7,8,9,11,14,15,16,17,18,20,21];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"expressions":3,"e":4,"EOF":5,"(":6,")":7,"and":8,"or":9,"silent":10,"friendly":11,"CODE":12,"TEXT":13,"parameter":14,"text":15,"condition":16,"label":17,"except":18,"exc":19,"details":20,",":21,"MATERIAL":22,"-":23,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",6:"(",7:")",8:"and",9:"or",10:"silent",11:"friendly",12:"CODE",13:"TEXT",14:"parameter",15:"text",16:"condition",17:"label",18:"except",20:"details",21:",",22:"MATERIAL",23:"-"},
productions_: [0,[3,2],[4,3],[4,3],[4,3],[4,2],[4,4],[4,1],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[19,3],[19,2],[19,1],[19,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
return $$[$0-1];
break;
case 2:
this.$ = $$[$0-1];
break;
case 3:
this.$ = {and: [$$[$0-2], $$[$0]]};
break;
case 4:
this.$ = {or: [$$[$0-2], $$[$0]]};
break;
case 5:
this.$ = $$[$0]; this.$.silent = true;
break;
case 6:
this.$ = $$[$0-3]; this.$.friendly = this.$.friendly || {}; this.$.friendly[$$[$0-1]] = $$[$0].substr(1, $$[$0].length - 2);
break;
case 7:
this.$ = {code: $$[$0]};
break;
case 8: case 9: case 10: case 11: case 13:
this.$ = $$[$0-2]; this.$[$$[$0-1]] = $$[$0].substr(1, $$[$0].length - 2);
break;
case 12:
this.$ = $$[$0-2]; this.$[$$[$0-1]] = $$[$0];
break;
case 14:
this.$ = $$[$0-2].concat($$[$0]);
break;
case 15:
this.$ = $$[$0]; this.$[0].materials = $$[$0-1].substr(1, $$[$0-1].length - 2)
break;
case 16:
this.$ = [{code: $$[$0], materials: 'materials'}];
break;
case 17:
this.$ = [{range: [$$[$0-2], $$[$0]], materials: 'materials'}];
break;
}
},
table: [{3:1,4:2,6:$V0,10:$V1,12:$V2},{1:[3]},{5:[1,6],8:$V3,9:$V4,11:$V5,14:$V6,15:$V7,16:$V8,17:$V9,18:$Va,20:$Vb},{4:16,6:$V0,10:$V1,12:$V2},{4:17,6:$V0,10:$V1,12:$V2},o($Vc,[2,7]),{1:[2,1]},{4:18,6:$V0,10:$V1,12:$V2},{4:19,6:$V0,10:$V1,12:$V2},{12:[1,20]},{13:[1,21]},{13:[1,22]},{13:[1,23]},{13:[1,24]},{12:$Vd,19:25,22:$Ve},{13:[1,28]},{7:[1,29],8:$V3,9:$V4,11:$V5,14:$V6,15:$V7,16:$V8,17:$V9,18:$Va,20:$Vb},o([5,7,8,9,14,15,16,17,18,20],[2,5],{11:$V5}),o([5,7,8,9],[2,3],{11:$V5,14:$V6,15:$V7,16:$V8,17:$V9,18:$Va,20:$Vb}),o([5,7,9],[2,4],{8:$V3,11:$V5,14:$V6,15:$V7,16:$V8,17:$V9,18:$Va,20:$Vb}),{13:[1,30]},o($Vc,[2,8]),o($Vc,[2,9]),o($Vc,[2,10]),o($Vc,[2,11]),o($Vc,[2,12],{21:[1,31]}),{12:$Vd,19:32,22:$Ve},o($Vf,[2,16],{23:[1,33]}),o($Vc,[2,13]),o($Vc,[2,2]),o($Vc,[2,6]),{12:$Vd,19:34,22:$Ve},o($Vf,[2,15]),{12:[1,35]},o($Vf,[2,14]),o($Vf,[2,17])],
defaultActions: {6:[2,1]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
        function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 12;
break;
case 2:return 13;
break;
case 3:return 22;
break;
case 4:return 21;
break;
case 5:return 23;
break;
case 6:return 10
break;
case 7:return 14
break;
case 8:return 15
break;
case 9:return 18
break;
case 10:return 16
break;
case 11:return 17
break;
case 12:return 20
break;
case 13:return 11
break;
case 14:return 6;
break;
case 15:return 7;
break;
case 16:return '<';
break;
case 17:return '>';
break;
case 18:return 8;
break;
case 19:return 9;
break;
case 20:return 5;
break;
}
},
rules: [/^(?:\s+)/,/^(?:[A-Z0-9_]+)/,/^(?:['][^']+['])/,/^(?:[<][^>]+[>])/,/^(?:,)/,/^(?:-)/,/^(?:silent\b)/,/^(?:parameter\b)/,/^(?:text\b)/,/^(?:except\b)/,/^(?:condition\b)/,/^(?:label\b)/,/^(?:details\b)/,/^(?:friendly\b)/,/^(?:\()/,/^(?:\))/,/^(?:<)/,/^(?:>)/,/^(?:and\b)/,/^(?:or\b)/,/^(?:$)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}

}).call(this,require('_process'))
},{"_process":5,"fs":3,"path":4}],2:[function(require,module,exports){
/**
 * @file Product Specific Rules Of Origin Module
 * 
 * @author Nahid Akbar
 * @year 2015
 * @copyright National ICT Australia (NICTA). All rights reserved.
 */

"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var grammar = require("./grammar");

var uglifyHS = function uglifyHS(code) {
  switch (code.length) {
    case 0:
      return '';
    case 1:
    case 2:
      return 'chapter ' + code;
    case 3:
    case 4:
      return 'heading ' + code;
    case 5:
    case 6:
      return 'subheading ' + code.substr(0, 4) + '.' + code.substr(4);
    default:
      return 'HS' + code.substr(0, 4) + '.' + code.substr(4, 2) + '.' + code.substr(6);
  }
};

var dumpHelper = function dumpHelper(tree) {
  var output = '';

  if (tree.or) {
    output = dumpHelper(tree.or[0]) + " or " + dumpHelper(tree.or[1]);
  }
  if (tree.and) {
    output = dumpHelper(tree.and[0]) + " and " + dumpHelper(tree.and[1]);
  }

  if (tree.code) {
    output += tree.code;
  }

  if (tree.parameter) {
    output += " parameter '" + tree.parameter + "'";
  }

  if (tree.text) {
    output += " text '" + tree.text + "'";
  }

  if (tree.except) {
    output += ' except ' + tree.except.map(function (excpt) {
      var prefix = '';
      if (excpt.materials !== 'materials') {
        prefix = "<" + excpt.materials + ">";
      }
      if (excpt.code) {
        return prefix + excpt.code;
      } else {
        return prefix + excpt.range.join('-');
      }
    }).join(',');
  }

  if (tree.condition) {
    output += " condition '" + tree.condition + "'";
  }

  if (tree.label) {
    output += " label '" + tree.label + "'";
  }

  if (tree.details) {
    output += " details '" + tree.details + "'";
  }

  if (tree.silent) {
    output = "silent (" + output + ")";
  }

  if (tree.friendly) {
    Object.keys(tree.friendly).forEach(function (category) {
      output = "(" + output + ") friendly " + category + " '" + tree.friendly[category] + "'";
    });
  }

  return output;
};

var officialHelper = function officialHelper(tree) {
  if (tree.silent) {
    return '';
  }

  if (tree.or) {
    return officialHelper(tree.or[0]) + ' or ' + officialHelper(tree.or[1]);
  }
  if (tree.and) {
    return officialHelper(tree.and[0]) + ' and ' + officialHelper(tree.and[1]);
  }

  if (tree.text) {
    return tree.text;
  } else {
    var output = '';
    if (tree.code) {
      if (/^\d+$/.test(tree.code)) {
        output += ' materials of ' + uglifyHS(tree.code);
      } else {
        output += tree.code;
      }
    }
    if (tree.parameter) {
      output += '(' + tree.parameter + ')';
    }

    if (tree.except) {
      output += ' except from ' + tree.except.map(function (excpt) {
        if (excpt.code) {
          return excpt.materials + " of " + uglifyHS(excpt.code);
        } else {
          return excpt.materials + " of " + uglifyHS(excpt.range[0]) + " through to " + uglifyHS(excpt.range[1]);
        }
      }).join(', ');
    }

    if (tree.condition) {
      output += ' ' + tree.condition;
    }
    return output.replace(/[ ]+/g, ' ').replace(/(^[ ]|[ ]$)/, '');
  }
};

var friendlyHelper = function friendlyHelper(tree, expanded, groups, category, settings) {

  if (tree.friendly && category in tree.friendly) {
    return tree.friendly[category];
  }

  if (tree.silent) {
    return '';
  }

  if (tree.or) {
    return friendlyHelper(tree.or[0], expanded, groups, category, settings) + ' or ' + friendlyHelper(tree.or[1], expanded, groups, category, settings);
  }

  if (tree.and) {
    return friendlyHelper(tree.and[0], expanded, groups, category, settings) + ' and ' + friendlyHelper(tree.and[1], expanded, groups, category, settings);
  }

  if (tree.code && tree.code in groups) {
    if (groups[tree.code] != category) {
      return '';
    }
  }

  if (tree.text) {
    return tree.text;
  } else {
    var output = '';
    if (tree.code) {
      if (/^\d+$/.test(tree.code)) {
        output += ' materials of ' + uglifyHS(tree.code);
      } else {
        output += tree.code;
      }
    }
    if (tree.parameter) {
      output += '(' + tree.parameter + ')';
    }

    if (tree.code in expanded) {
      if (tree.parameter) {
        output = expanded[tree.code] + (settings.hideItemCode ? '' : ' - ' + output);
      } else {
        output = expanded[tree.code] + (settings.hideItemCode ? '' : ' (' + output + ')');
      }
    }

    if (tree.except) {
      output += ' except from ' + tree.except.map(function (excpt) {
        if (excpt.code) {
          return excpt.materials + " of " + uglifyHS(excpt.code);
        } else {
          return excpt.materials + " of " + uglifyHS(excpt.range[0]) + " through to " + uglifyHS(excpt.range[1]);
        }
      }).join(', ');
    }

    if (tree.condition) {
      output += ' ' + tree.condition;
    }
    return output;
  }
};

var codesHelper = function codesHelper(tree) {
  var array = [];
  if (tree.or) {
    array = array.concat(codesHelper(tree.or[0]));
    array = array.concat(codesHelper(tree.or[1]));
  }
  if (tree.and) {
    array = array.concat(codesHelper(tree.and[0]));
    array = array.concat(codesHelper(tree.and[1]));
  }
  if (tree.code) {
    array.push(tree.code);
  }
  return array;
};

var conditionsHelper = function conditionsHelper(tree, arr) {
  var array = arr || {};
  if (tree.or) {
    conditionsHelper(tree.or[0], array);
    conditionsHelper(tree.or[1], array);
  }
  if (tree.and) {
    conditionsHelper(tree.and[0], array);
    conditionsHelper(tree.and[1], array);
  }
  if (tree.code && tree.except) {
    if (!array[tree.code]) {
      array[tree.code] = [];
    }
    tree.except.forEach(function (excpt) {
      if (excpt.code) {
        array[tree.code].push("provided that it is not a change from " + excpt.materials + " of " + uglifyHS(excpt.code));
      } else {
        array[tree.code].push("provided that it is not a change from " + excpt.materials + " of " + uglifyHS(excpt.range[0]) + " through to " + uglifyHS(excpt.range[1]));
      }
    });
  }
  if (tree.code && tree.condition) {
    if (!array[tree.code]) {
      array[tree.code] = [];
    }
    array[tree.code].push(tree.condition);
  }
  return array;
};

var labelsHelper = function labelsHelper(tree, arr) {
  var array = arr || {};
  if (tree.or) {
    labelsHelper(tree.or[0], array);
    labelsHelper(tree.or[1], array);
  }
  if (tree.and) {
    labelsHelper(tree.and[0], array);
    labelsHelper(tree.and[1], array);
  }
  if (tree.code && tree.label) {
    array[tree.code] = tree.label;
  }
  return array;
};

var detailsHelper = function detailsHelper(tree, arr) {
  var array = arr || {};
  if (tree.or) {
    detailsHelper(tree.or[0], array);
    detailsHelper(tree.or[1], array);
  }
  if (tree.and) {
    detailsHelper(tree.and[0], array);
    detailsHelper(tree.and[1], array);
  }
  if (tree.code && tree.details) {
    if (!array[tree.code]) {
      array[tree.code] = [];
    }
    array[tree.code].push(tree.details);
  }
  return array;
};

var evaluateHelper = function evaluateHelper(tree, values, blacklist) {
  if (tree.or) {
    var a = evaluateHelper(tree.or[0], values, blacklist);
    var b = evaluateHelper(tree.or[1], values, blacklist);
    if (a === 'applicable' || b === 'applicable') {
      return 'applicable';
    }
    if (a === 'unclear' || b === 'unclear') {
      return 'unclear';
    }
    return 'inapplicable';
  }
  if (tree.and) {
    var a = evaluateHelper(tree.and[0], values, blacklist);
    var b = evaluateHelper(tree.and[1], values, blacklist);
    if (a === 'applicable' && b === 'applicable') {
      return 'applicable';
    }
    if (a === 'inapplicable') {
      codesHelper(tree.and[1]).forEach(function (code) {
        return blacklist[code] = true;
      });
      return 'inapplicable';
    }
    if (b === 'inapplicable') {
      codesHelper(tree.and[0]).forEach(function (code) {
        return blacklist[code] = true;
      });
      return 'inapplicable';
    }
    return 'unclear';
  }
  if (values[tree.code] === undefined) {
    return 'unclear';
  } else if (values[tree.code] === true) {
    return 'applicable';
  } else {
    return 'inapplicable';
  }
};

var PSR = (function () {
  function PSR(tree, roo) {
    _classCallCheck(this, PSR);

    this.tree = tree;
    this.roo = roo;

    this.official = officialHelper(this.tree).replace(/\s+/g, ' ').replace(/(^[ ]|[ ]$)/, '').replace(/^(or|and| )*|(or|and| )*$/g, '');

    var codes = codesHelper(this.tree);

    var conditions = conditionsHelper(this.tree);
    var labels = labelsHelper(this.tree);
    var details = detailsHelper(this.tree);
    var categoryById = {};
    var questionById = {};

    this.friendlyExpanded = {};
    this.friendlyGroupingException = {};

    this.all = {};
    this.categories = [];
    this.questions = [];
    this.outcomes = {};
    var that = this;

    roo.forEach(function (item, index) {
      item.item = index;
      switch (item.type) {
        case 'category':
          categoryById[item.itemIf] = item;
          that.categories.push(item);
          item.questions = [];
          break;
        case 'question':
          var included = false;
          item.itemIf.split(',').forEach(function (itm) {
            if (codes.indexOf(itm) != -1) {
              included = true;
            }
          });
          if (included) {
            that.questions.push(item);
            categoryById[item.parentCategory].questions.push(item);
            if (item.itemIf in labels) {
              item.label = labels[item.itemIf];
            }
            item.details = item.details || '';
            if (item.itemIf in details) {
              //item.details += details[item.itemIf].join('\n\n');
              item.details = details[item.itemIf].join('\n\n');
            }
            if (item.itemIf in conditions) {
              item.conditions = conditions[item.itemIf];
              item.label = item.label.replace(/\?$/, " in accordance with the following rules?");
              item.details += '\n\nThe addition of "provided that" or "except from" in the rule creates additional parameters that must be followed for the product to qualify under this rule. Please follow closely the wording of the rule in selecting "yes" or "no" for this question.';
            }

            item.details = item.details.replace(/(^\s*|\s*$)/g, '');
          }
          if (item.parentCategory) {
            that.friendlyGroupingException[item.itemIf] = item.parentCategory;
          }
          if (item.itemIfText) {
            that.friendlyExpanded[item.itemIf] = item.itemIfText;
          }
          questionById[item.itemIf] = item;
          break;
        case 'outcome':
          that.outcomes[item.itemIf] = item;
          break;
      }
      that.all[item.item] = item;
    });

    codes.filter(function (code) {
      return !(code in questionById);
    }).forEach(function (code) {
      throw new Error("Question related to " + code + " does not exist.");
    });

    this.categories.forEach(function (category) {
      category.friendlyRules = friendlyHelper(that.tree, that.friendlyExpanded, that.friendlyGroupingException, category.itemIf, category).replace(/\s+/g, ' ').replace(/(^[ ]|[ ]$)/, '').replace(/^(or|and| )*|(or|and| )*$/g, '');
    });
    this.iterate();
  }

  _createClass(PSR, [{
    key: "dump",
    value: function dump() {
      return dumpHelper(this.tree);
    }
  }, {
    key: "iterate",
    value: function iterate(answers) {
      var answers = answers || {};
      var that = this;

      var blacklist = {};
      var values = {};
      var outcome = 'unclear';
      for (var q = 0; q < this.questions.length && outcome == 'unclear'; q++) {
        this.questions[q].visible = false;
      }
      for (var q = 0; q < this.questions.length && outcome == 'unclear'; q++) {
        var question = this.questions[q];
        if (!(question.itemIf in blacklist)) {
          question.visible = true;
          if (answers[question.itemIf] === true || answers[question.itemIf] === false) {
            values[question.itemIf] = answers[question.itemIf] === true;
            outcome = evaluateHelper(this.tree, values, blacklist);
          } else {
            break;
          }
        }
      }

      Object.keys(that.categories).map(function (cat) {
        return that.categories[cat];
      }).forEach(function (category) {
        category.visible = false;
        category.questions.forEach(function (question) {
          category.visible = category.visible || question.visible;
        });
      });

      return this.outcomes[outcome];
    }
  }, {
    key: "iterate2",
    value: function iterate2(answers) {
      var answers = answers || {};
      var that = this;

      var blacklist = {};
      var values = {};
      var outcome = 'unclear';
      for (var q = 0; q < this.questions.length; q++) {
        var question = this.questions[q];
        question.visible = false;
        if (outcome === 'unclear' && (answers[question.itemIf] === true || answers[question.itemIf] === false)) {
          values[question.itemIf] = answers[question.itemIf] === true;
          question.visible = true;
          outcome = evaluateHelper(this.tree, values, blacklist);
        }
      }

      outcome = 'unclear';

      for (var q = 0; q < this.questions.length && outcome === 'unclear'; q++) {
        var question = this.questions[q];
        question.visible = true;
        if (answers[question.itemIf] === true || answers[question.itemIf] === false) {
          values[question.itemIf] = answers[question.itemIf] === true;
          outcome = evaluateHelper(this.tree, values, blacklist);
        } else {
          break;
        }
      }

      Object.keys(that.categories).map(function (cat) {
        return that.categories[cat];
      }).forEach(function (category) {
        category.visible = false;
        category.questions.forEach(function (question) {
          category.visible = category.visible || question.visible;
        });
        if (category.visible) {
          category.questions.forEach(function (question) {
            question.visible = true;
          });
        }
      });

      return this.outcomes[outcome];
    }
  }], [{
    key: "parse",
    value: function parse(text, roo) {
      return new PSR(grammar.parse(text), JSON.parse(JSON.stringify(roo)));
    }
  }]);

  return PSR;
})();

module.exports = PSR;
},{"./grammar":1}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":5}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[2])(2)
});